<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Worms: Object Oriented Design - Preferring Composition Over Inheritance</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Worms
   </div>
   <div id="projectbrief">Developed by Erik M. Buck for CS-7140-C01 Wright State University Summer 2016</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_README.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Object Oriented Design - Preferring Composition Over Inheritance </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>by Erik M. Buck June 2016</p>
<h1><a class="anchor" id="mainpage"></a>
Abstract</h1>
<p>A goal of object-oriented programming is to maximize programmer productivity by reducing lifetime software development and maintenance costs. The principal technique used to achieve the goal is [object reuse]. An object that is reused saves the programmer time because the object would otherwise need to be reimplemented for each new project. Another potential benefit of reusing objects is that when new features are required or bugs are identified, changes can often be made to a small number of objects, and those changes benefit other projects that rely on the same objects. Most importantly, by reusing objects, fewer total lines of code are written to solve each new problem, and that means there are fewer lines of code to maintain as well.</p>
<p>Several guiding principles of design promote object reuse, and foremost among those principles is [minimization of coupling]. Coupling refers to dependencies between objects. Whenever such dependencies exist, they reduce opportunities for reusing the objects independently. Coupling frequently manifests as situations in which changes to one object necessitate changes to other objects or when one object cannot be reused without also requiring reuse of other objects. Coupling also applies to subsystems within large systems of objects. To achieve object reuse, it's important to look for designs that avoid coupling whenever possible.</p>
<p>This paper examines one of the most common and most severe sources of coupling, object oriented inheritance, and describes use of designs emphasizing composition relationships in preference to inheritance relationships between objects. The classic but trivial "Worms" simulation program is used as a case study. A brief overview of the "Worms" simulation is provided as a basis and case study for application of composition in preference to object oriented inheritance.</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Contents</h2>
<p>Object Oriented Design - Preferring Composition Over Inheritance: 1</p>
<p>"Worms" Simulation Case Study 1</p>
<p>Abstract 1</p>
<p>Overview of the "Worms" Simulation 3</p>
<p>Board 3</p>
<p>Worms 3</p>
<p>Examination of Design Alternatives 4</p>
<p>Inheritance Based Design 1 4</p>
<p>Critique of Design 1: 5</p>
<p>Composition Based Design 2 6</p>
<p>Critique of Design 2: 7</p>
<p>Appropriate Use of Inheritance in Design 3 8</p>
<p>Conclusion 8</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Overview of the "Worms" Simulation</h1>
<p>The Worms program simulates worms living their lives in a 2D plane called a board. See Figure 1: Examples of Worms On a Game Board.<img src="../media/image001.png" alt="" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md3"></a>
Board</h2>
<p>The board is represented by a matrix of squares. Positions within the board are denoted by the natural number coordinates of each square in the matrix. Each square may contain zero or one element from the set *{carrot, segment from non-alive worm}* as well as zero or more worm segments of alive worms. See the Worms Section for a description of non-alive worm, alive worm, and worm segments. Carrots and segments of alive worms have a food value that nourishes any worm that eats them.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Worms</h2>
<p>Three types of worm are simulated: <em>Vegetarian</em>, <em>Scissor</em>, and <em>Cannibal</em>. Worms may be <em>alive</em>, <em>dead</em>, or <em>eaten</em>. Each worm is composed of one <em>head segment</em> and zero or more <em>non-head segments</em>. Each alive worm[]s head may move in pseudo random directions by changing its position form one position in the board to an adjacent position within the board. If a worm segment moves off an edge of the board, the worm segment wraps around to the opposite side of the board. Non-head segments are ordered with respect to the head and other non-head segments in the same worm. Whenever a segment moves, the immediately subsequent segment if any in the same worm moves to occupy the position just vacated by the segment that moved. In other words, the head moves around the board and non-head segments follow the preceding segment.</p>
<p>Vegetarian worms, Scissor worms, and Cannibal worms may eat any carrot at the same position in the board as the worm's head. Eaten carrots are removed from the board. Cannibal worms may also eat any entire alive worm if the alive worms is composed of one or more segments at the same position as the Cannibal worm's head. Eaten worms are removed from the board. Scissor worms may "slice" any alive worm if the alive worm is composed of one or more segments at the same position as the Scissor worm's head. When a worm is sliced, a sliced worm's segment at the same position as the Scissor worm's head is removed from the board. Any segments preceding the removed segment in the sliced worm remain part of the sliced worm. Any segments after the removed segment in the sliced worm may become part of a new worm with a head at the position of the segment immediately after the removed segment in the sliced worm.</p>
<p>Each alive worm has a stomach with food storage capacity proportional to the number of segments in the worm. Each time an alive worm moves, it consumes some of the food in the its stomach. Each time an alive worm eats, it increases the amount of food in the its stomach. If a worm's stomach becomes empty, the worm becomes dead.</p>
<p>Examination of Design Alternatives</p>
<p>An inheritance based design is examined and critiqued here followed by a design that employs composition instead of inheritance. Then, a design aspect that effectively employs inheritance without incurring excessive coupling is presented.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Inheritance Based Design 1</h2>
<p>There are three types of <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a>, Vegetarian, Scissor Head, and Cannibal. A natural design<img src="../media/image003.png" alt="" class="inline"/> inclination might be to create an abstract <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> class that has three concrete subclasses, VegetarianWorm, ScissorHeadWorm, and CannibalWorm. The abstract <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> class presumably declares an interface and possibly some behaviors that all types of worms inherit. The three concrete subclasses of <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> specialize and potentially augment whatever interface and behaviors are defined for all Worms.</p>
<p>To elaborate this design, consider what information is common to all Worms: All worms may be <em>alive</em>, <em>dead</em>, or <em>eaten,</em> so we could encapsulate the <em>alive</em>, <em>dead</em>, or <em>eaten</em> states in the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> class. All worms have segments including a head, so we could encapsulate storage of segments within the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> class. All alive worms move within the board, so we could encapsulate a test for alive-ness and worm head movement and subsequent non-head segment movement behavior within the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> class. We could even declare an abstract <em>template method</em>, <em>eat()</em>, in the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> class and require that each concrete subclass of <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> implement the <em>eat()</em> method in a way appropriate for the type of worm represented by the concrete class. Note: A <em>template method</em> is a base class method intended/required to be overridden in subclasses to specialize an algorithm implemented primarily in the base class. Ref: <a href="https://en.wikipedia.org/wiki/Template_method_pattern">[https://en.wikipedia.org/wiki/Template_method_pattern]{.ul}</a> In this case, all worms eat under certain circumstances, but how and what they eat depends on the type of worm. The algorithm to evaluate when it is situationally appropriate to eat can be encapsulated in the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> base class which, as part of the algorithm implementation, calls the <em>eat()</em> method as appropriate. By polymorphicly overriding the <em>eat()</em> method, the subclasses specialize or customize the inherited algorithm without need to know any details about the algorithm.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Critique of Design 1:</h2>
<p><b>The <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> subclasses either encapsulate too little or too much</b>: It is apparent that substantial portions of the simulation logic may be encapsulated in an abstract <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> class, but what exactly is encapsulated by the concrete subclasses of <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a>? In Design 1, the concrete subclasses essentially exist to override the <em>eat()</em> method. It is possible to imagine other differences between the types of worm besides eating behavior. For example, worms might move following logic specific to the type of worm. CannibalWorm instances might travel directly towards other worms while VegetarianWorm instances travel away from other worms. A movement algorithm encapsulated by the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> class could be implemented using a template method, <em>move()</em>, that subclasses override. Similarly, different worm types might have different stomach sizes or consume more or less food per movement. Those differences could be encapsulated in concrete subclasses of <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> as well. However, if concrete subclasses exist almost entirely to override exactly one method, having the concrete subclasses at all is a heavy handed solution to a simple problem. At the other extreme, if nearly every aspect of <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> behavior is specialized by concrete subclasses, what remains in the base class to be reused? At the extreme, every method of the base class is overridden in a subclass. In that situation, why not use a Java style <em>interface</em> or C++ style <em>pure-abstract class</em> and not have a <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> base class or at least not implement any logic in the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> base class?</p>
<p><b>Concrete subclasses of <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> are coupled to the base class</b>: In Design 1, an algorithm that implements worm behavior calls an <em>eat()</em> method that may be overridden by subclasses of <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> to specialize eating behavior. What happens if the type signature (required parameters and/or the return type) of the <em>eat()</em> method is changed in the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> class? Generally, every subclass of <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> must then be modified to provide new <em>eat()</em> implementations satisfying the new signature. When one class cannot be changed without requiring changes to other classes, that is the very definition of coupling. This is the famous Fragile-Base-Class Problem that every Object Oriented Language suffers to some degree. <a href="https://en.wikipedia.org/wiki/Fragile_base_class">[https://en.wikipedia.org/wiki/Fragile_base_class]{.ul}</a> To elaborate, what if the maintainer of the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> class is unaware of concrete subclasses implemented my other teams? How are the other teams notified to make required changes prior to rebuilding with the supposedly reusable <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> simulation support library? Maybe other projects decide to forego updating to the latest version of the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> class, but then, what if the change to the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> class signature for the <em>eat()</em> method was made as part of correcting a serious bug or security flaw? Changing the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> base class inDesign 1 essentially requires recompilation of every <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> subclass and every subclass of the subclasses ad infinitum. This opens a Pandora's box for regression testing.</p>
<p><b>The Design 1 class hierarchy does not make sense or reflect reality/standard understanding of terms</b>: All worms eat carrots under some circumstances, but VegitarianWorms exclusively eat carrots. Where should carrot eating behavior be implemented? Carrot eating could implemented in the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> base class so that all subclasses may invoke the base class behavior when it is appropriate to eat carrots. In that design, what exactly makes the VegetarianWorm class different from the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> base class? It may be possible to eliminate the VegetarianWorm class or more likely<img src="../media/image004.png" alt="" class="inline"/> replace the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> base class with the VegetarianWorm class so that ScissorHeadWorm and CannibalWorm are subclasses of VegitarianWorm. But does it make sense to say that a CannibalWorm IS-A VegetarianWorm? This design likely violates the Liskov Substitution Principle (LSP) in the sense that there may be situations where VegetarianWorms may be used where CannibalWorms may not. For example, simulation of a worm nursery where all worms are expected survive when fed with ample carrots cannot tolerate introduction of CannibalWorm instances, but LSP specifically requires that instances of CannibalWorm be usable in any situation where instances of the superclass, VegitarianWorm may be used. Even without invoking LSP, it is absurd to say a cannibal IS-A vegitarian - ask any vegetarians you know. But, we arrived at the design of making CannibalWorm a subclass of VegitarianWorm because i) all worm types sometimes invoke carrot eating behavior, ii) it therefore makes sense to put carrot eating behavior in the base class, iii) there is no content to a VegitarianWorm subclass of the base class if carrot eating behavior is implemented in the base class. It is possible to implement carrot eating in the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> base class and retain an empty VegetarianWorm class just to differentiate worms that exclusively eat carrots from worms that sometimes eat non-carrots, but creating empty subclasses seems silly or excessively convoluted.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Composition Based Design 2</h2>
<p>Even in Design 1, we implicitly accept that each <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> instance HAS some number of segments. We don't say a worm IS-A collection of worm segments. We could do that: If we have a collection class that stores instances of other classes, we could create the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> class as a subclass of the collection class that specializes the collection class to store worm segments and implement worm behaviors. We instinctively understand that it is inappropriate to subclass a general purpose collection in such a way. Such a subclass also violates LSP because we cannot use a <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> (that is a specialized collection of worm segments) in every situation where we could use the base collection class.</p>
<p>It is clear upon examination that each worm HAS-A eating behavior as opposed to saying each worm type IS-A <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> that specializes eating in some way. In Design 1, substantial data and logic are encapsulated in the abstract <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> base class. In Design 2, we make the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> class concrete and deliberately avoid creating any subclasses of <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a>. We do this by choosing to "encapsulate what is common and parameterize what is
different". The difference between worms is their eating behavior, so why not parameterize that difference. In other words, each instance of <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> HAS-A pointer to a function to call when eating. If there are other differences between worms such as movement behavior, stomach capacity, food consumed per move, etc., we parameterize those as well. Each worm HAS-A stomach capacity. Each worm HAS-A movement style. Each worm HAS-An amount of food consumed per move.</p>
<p>Design 2 provides additional flexibility not available in Design 1. For example, because each worm HAS-A eating behavior, that behavior may be changed over time. A worm might begin life as a cannibal but undergo an ethical transformation to become a vegetarian. In Design 2, such a worm may change its <em>eat()</em> function pointer at any point at run time. In Design 1, the worm would somehow need to change its class at some point in run time. Aspect oriented programming enables such transformations, but the transformations are not generally available or advisable in object oriented languages.</p>
<p>Design 2 potentially avoids an explosion of classes. What would happen in Design 1 if it is later determined there are 2000 different eating behaviors for worms. Would it make sense to create 2000 subclasses of the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> class? Parameterizing differences avoids the problem. It is much cleaner and simpler to implement 2000 functions than to implement 2000 classes. This is related to the traditional example of composition in graphical user interfaces. We say a text display view has a horizontal scroll bar and it has a vertical scroll bar and it has a set of tab stops and it has particular text content. If we are not Microsoft, we don't say a text view is text content and also it is a horizontal scroller and it is a vertical scroller and it is a set of tab stops. Imagine a class hierarchy: <em>TextContent-&gt;TextContentThatScrollsHorizontally-&gt;TextContentThatScrollsHorizontallyAndVertically-&gt;TextContenThatScrollsHorizontallyAndVerticallyAndHasASetOfTabStops</em>. Then, what happens when the programmer needs text content that scrolls vertically and has tab stops but doesn't scroll horizontally?</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Critique of Design 2:</h2>
<p><b>There remains a "fragile type signature problem"</b>: Critique B) of Design 1 describes the Fragile-Base-Class Problem noting that any change to a base class method signature potentially requires recompilation of all subclass implementations and all subclasses of those subclasses and possibly every other class that uses one of those subclasses, etc. Recompiling so much code opens a Pandora's box for regression testing. What if instead, each instance of <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> HAS-A pointer to a function it can call when it is appropriate to eat. It may be argued that changing the signature for a <em>eat()</em> function pointer has consequences equally severe to changing the signature of an <em>eat()</em> method intended to be overridden in subclasses. The difference is that the various <em>eat()</em> functions may be declared and implemented in isolation (as the only content of respective implementation files) so that only recompilation of the specific files containing the functions is required. By restricting recompilation to fewer files and certainly much less code, the regression test burden imposed by the change <em>eat()</em> function pointer signature may be greatly reduced. Nevertheless, there remains an form of coupling between the <em>eat()</em> function pointer signature and the various implementations of <em>eat()</em> functions. The problem is a form of "fragile type signature problem" instead of being a Fragile-Base-Class problem. Programming languages that infer type from usage avoid even the "fragile type signature problem". A common way to avoid the fragility is to use the Command Pattern, "Functors", or Labdas. Each of these provide a way to encapsulate arbitrary [immutable] state in an object or language feature the works like a function. Instead of storing a function pointer, store a command, functor, or lambda. These approaches avoid the need to change the function signature in most cases because any unanticipated information needs that may be discovered may be encapsulated the individual commands, functors, or lamas.</p>
<p><b>There may still be a need for an empty base class</b>: There is no longer an issue with LSP in Design 2 because substitution applies only to subclasses, and Design 2 specifically avoids creation of subclasses. However, what happens if it is later discovered that subclasses of the <a class="el" href="classWorm.html" title="This class encapsulates a &quot;worm&quot; which lives, eats, moves, and eventually dies.">Worm</a> base class are needed in spite of previous parameterization of differences between worms? It is usually easier to maintain Leskov substitutability when there are fewer subclasses and fewer overrides of base class methods, but Design 2 does not necessarily foreclose the possibility of introducing LSP problems. Design 2 merely greatly reduces the potential for needing a myriad of subclasses.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Appropriate Use of Inheritance in Design 3</h2>
<p>Base classes are ideally entirely abstract. In other words, if a base class is found to be needed, make it a pure-abstract-base-class in the C++ style or an Interface in the Java style. Consider the <em>Strategy Design Pattern</em> <a href="https://en.wikipedia.org/wiki/Strategy_pattern">[https://en.wikipedia.org/wiki/Strategy_pattern]</a> and how it may apply to the Worms simulation.</p>
<p>The <em><b>abstract</b></em> <a class="el" href="classAbstractWormsSimUIStrategy.html" title="The abstract AbstractWormsSimUIStrategy class (similar to a Java or C# Interface or an Objective-C Pr...">AbstractWormsSimUIStrategy</a> class (similar to a Java or C# <em>Interface</em> or an Objective-C <em>Protocol</em>) declares the methods needed by any class that displays Worms simulation state to a user and/or accepts user input. <a class="el" href="classAbstractWormsSimUIStrategy.html" title="The abstract AbstractWormsSimUIStrategy class (similar to a Java or C# Interface or an Objective-C Pr...">AbstractWormsSimUIStrategy</a> collaborates as part of an implementation<img src="../media/image005.png" alt="" class="inline"/> of the <em>Strategy Design Pattern.</em> The assumption is that many different concrete strategies for displaying Worms simulation state to users and accepting user input may exist. For example, there may be a terminal (Curses) based textual display or a 2D vector graphics display or a 3D display. Similarly, user input may come from a keyboard or over a network connection or from a data file or from script.</p>
<p>Observe that in this design, the simulation HAS-A strategy for interacting with the user. In essence, the strategy is parameterized in much the same way the <em>eat()</em> function is parameterized in Design 2. The only difference is that we are parameterizing more than one function in a single declaration. Our design communicates that all of the methods defined in the <a class="el" href="classAbstractWormsSimUIStrategy.html" title="The abstract AbstractWormsSimUIStrategy class (similar to a Java or C# Interface or an Objective-C Pr...">AbstractWormsSimUIStrategy</a> must be implemented for each strategy the simulation might employ. A single instance of the Worms simulation might have multiple strategies at one time (perhaps displaying on several different screens or supporting remote input and local input simultaneously). An instance of Worms simulation might change its strategy at run time (perhaps in reaction to the display resolution change).</p>
<p>Concrete subclasses of <a class="el" href="classAbstractWormsSimUIStrategy.html" title="The abstract AbstractWormsSimUIStrategy class (similar to a Java or C# Interface or an Objective-C Pr...">AbstractWormsSimUIStrategy</a> implement the interface specified by the <a class="el" href="classAbstractWormsSimUIStrategy.html" title="The abstract AbstractWormsSimUIStrategy class (similar to a Java or C# Interface or an Objective-C Pr...">AbstractWormsSimUIStrategy</a> class and participate in the Strategy design pattern to [explicitly decouple display and user input from simulation encapsulation].</p>
<p>The Strategy Design Pattern adheres to the practical advice from Scott Meyers, *"More Effective C++: 35 New Ways to Improve Your Programs and
Designs 1st Edition" Item 33, "Make non-leaf classes abstract" as elaborated to use the Template Method design pattern in "Virtuality:
C/C++ Users Journal, 19, September 2001"* <a href="http://www.gotw.ca/publications/mill18.htm">http://www.gotw.ca/publications/mill18.htm</a>.</p>
<p>Use of object oriented inheritance is most appropriate when all non-leaf classes in the inheritance hierarchy are abstract. In other words, interface inheritance is preferred over implementation inheritance.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Conclusion</h1>
<p>Seminal work in object oriented design patterns has produces a collection of reusable patterns that describe known good solutions to recurring design problems. This paper does not restate the motivation for creating and using design patters even though two of the most prominent object oriented design patterns, <em>Template Method</em> and <em>Strategy</em>, are applied in the designs described by this paper. Nevertheless, it is vital to recognize that all of the now famous design patterns exist entirely or in part to reduce coupling between components in large software systems.</p>
<p>Object oriented inheritance can be a powerful tool. In the sense that subclasses reuse logic and data inherited from base classes, inheritance actually provides a measure (small and localized) of software reuse. Paradoxically, object oriented inheritance also introduces the tightest possible coupling between base classes and derived subclasses. Design patterns can be seen as approaches that avoid use of inheritance. In cases where inheritance is still employed, interface inheritance is strongly preferred over implementation inheritance. Design patterns promote software reuse at a scale larger than individual methods of individual classes.</p>
<p>The following statement succinctly summarizes the case study presented in this paper and the purpose of all or most software design patterns: *"To promote software reuse, it is essential to avoid coupling, and to avoid coupling, it is essential to avoid object oriented inheritance, and when inheritance is employed, interface inheritance is strongly preferred over implementation inheritance."* </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
